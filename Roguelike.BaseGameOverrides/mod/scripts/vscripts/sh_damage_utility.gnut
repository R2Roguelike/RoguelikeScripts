untyped

global function IsValidHeadShot
global function IsInstantDeath
global function IsTitanCrushDamage
global function IsMaxRangeShot
global function IsMidRangeShot
global function IsSuicide

#if SERVER
global function CritWeaponInDamageInfo
global function GetCriticalScaler
global function HeavyArmorCriticalHitRequired
#endif

#if CLIENT
global function ServerCallback_QuickDeathRumble
#endif

#if SERVER

bool function HeavyArmorCriticalHitRequired( var damageInfo )
{
	entity weapon = DamageInfo_GetWeapon( damageInfo )
	if ( weapon )
		return weapon.GetWeaponSettingBool( eWeaponVar.titanarmor_critical_hit_required )

	entity inflictor = DamageInfo_GetInflictor( damageInfo )
	if ( !inflictor )
		return false
	if ( !inflictor.IsProjectile() )
		return false

	return inflictor.GetProjectileWeaponSettingBool( eWeaponVar.titanarmor_critical_hit_required )
}

bool function CritWeaponInDamageInfo( var damageInfo )
{
	entity weapon = DamageInfo_GetWeapon( damageInfo )
	if ( weapon )
		return weapon.GetWeaponSettingBool( eWeaponVar.critical_hit )

	entity inflictor = DamageInfo_GetInflictor( damageInfo )
	if ( !inflictor )
		return false
	if ( !inflictor.IsProjectile() )
		return false

	return inflictor.GetProjectileWeaponSettingBool( eWeaponVar.critical_hit )
}

float function Roguelike_GetCritRate( entity player, entity victim, var damageInfo )
{
	float base = Roguelike_BaseCritRate( Roguelike_GetStat( player, STAT_ENERGY ) )

	if (StatusEffect_Get( victim, eStatusEffect.roguelike_puncture ) > 0.0)
		base += 0.25
		
	if ("weaponCrit" in player.s)
	{
		if (Time() - player.s.lastWeaponHitTime > 3.0)
			player.s.weaponCrit = 0
		
		base += 0.005 * expect int(player.s.weaponCrit)
		if (verboseDamagePrintouts)
			printt(format("+%.1f%% Crit Rate from Weapon Crit", 1 * expect int(player.s.weaponCrit)))
	}

	bool guranteedCrit = false

	if (Roguelike_HasMod( player, "ronin_dash_melee" ) && Time() - GetLastDodgeTime() < 1.0)
		guranteedCrit = true

	if (guranteedCrit)
		base += 1.0

	return base
}

float function Roguelike_GetCritDMG( entity player, entity victim, var damageInfo )
{
	float base = Roguelike_BaseCritDMG( Roguelike_GetStat( player, STAT_POWER ) )

	entity weapon = Roguelike_FindWeaponForDamageInfo( damageInfo )
	if ( IsValid( weapon ) && weapon.GetWeaponClassName() == "mp_titanweapon_predator_cannon" && weapon.HasMod("LongRangeAmmo") 
		&& Roguelike_HasMod( player, "focus_crystal") )
		base += 0.25


	return base
}

float function GetCriticalScaler( ent, damageInfo )
{
	expect entity (ent)
	entity attacker = DamageInfo_GetAttacker( damageInfo )
	int hitBox = DamageInfo_GetHitBox( damageInfo )
	local damageAmount = DamageInfo_GetDamage( damageInfo )
	bool randomCrits = !CritWeaponInDamageInfo( damageInfo )

	if (!attacker.IsPlayer()) // enemies dont crit
		return 1.0


	float critRate = Roguelike_GetCritRate( attacker, ent, damageInfo )
	float critDMG = Roguelike_GetCritDMG( attacker, ent, damageInfo )

	if (critRate > 1.0 && ent.IsTitan())
	{
		if (Roguelike_HasMod( attacker, "puncture_crit_dmg" ))
			critDMG += critRate - 1.0
	}

	if ( !randomCrits )
	{
		critDMG += critRate // non-random crit weapons convert crit rate to crit dmg
	}

	if (verboseDamagePrintouts)
	{
		printt(format("   Crit Rate: %.1f%%", critRate * 100.0))
		printt(format("   Crit DMG:  %.1f%%", critDMG * 100.0))
		printt("   Random Crits: ", randomCrits)
	}

	bool hitCritSpot = IsCriticalHit( attacker, ent, hitBox, damageAmount, DamageInfo_GetDamageType( damageInfo ) )

	if ( (RandomFloat(1.0) < critRate && randomCrits) || (hitCritSpot && !randomCrits) )
	{	
		if (verboseDamagePrintouts)
			print(format("   Critical Hit! +%.1f%% DMG", critDMG * 100.0 ))

		DamageInfo_AddCustomDamageType( damageInfo, DF_CRITICAL )
		return 1.0 + critDMG
	}

	DamageInfo_RemoveCustomDamageType( damageInfo, DF_CRITICAL )
	return 1.0
}
#endif // SERVER

bool function IsValidHeadShot( var damageInfo = null, entity victim = null, entity attacker = null, entity weapon = null, int hitGroup = -1, float attackDist = -1.0, entity inflictor = null )
{
	// Pass this function damageInfo if you can, otherwise you'll have to fill out all the other params. If using damageInfo you dont need to.
	local inflictor
	if ( damageInfo != null )
	{
		if ( DamageInfo_GetCustomDamageType( damageInfo ) & DF_HEADSHOT )
			return true

		attacker = DamageInfo_GetAttacker( damageInfo )
		weapon = DamageInfo_GetWeapon( damageInfo )
		hitGroup = DamageInfo_GetHitGroup( damageInfo )
		int hitBox = DamageInfo_GetHitBox( damageInfo )
		//Some models can be shot that don't have models. Adding victim.GetModelName() check to prevent script error.
		if ( IsValid( victim ) && hitGroup <= HITGROUP_GENERIC && hitBox >= 0 )
			hitGroup = GetHitgroupForHitboxOnEntity( victim, DamageInfo_GetHitBox( damageInfo ) )
		attackDist = DamageInfo_GetDistFromAttackOrigin( damageInfo )
		inflictor = DamageInfo_GetInflictor( damageInfo )
	}

	if ( IsValid( attacker ) && attacker.IsTitan() && (!IsValid( victim ) || !IsSpectre( victim )) )
		return false

	if ( !IsValid( attacker ) || !attacker.IsPlayer() )
		return false
	
	bool hasRandomHeadshots = !attacker.IsTitan() && Roguelike_HasMod( attacker, "random_headshot" )
	if ( (!hasRandomHeadshots || RandomFloat( 1.0 ) > 0.15) && hitGroup != HITGROUP_HEAD )
		return false


//	if ( IsSpectre( victim ) )
//	{
//		return false
//		//// head shot off?
//		//int bodygroup = victim.FindBodyGroup( "removableHead" )
//		//if ( bodygroup != -1 && victim.GetBodyGroupState( bodygroup ) == 1 )
//		//	return false
//	}

	if ( IsValid( weapon ) )
	{
		if ( !( "headshotDistance" in weapon.s ) )
			weapon.s.headshotDistance <- weapon.GetMaxDamageFarDist()

		Assert( weapon.s.headshotDistance != null )
		if ( attackDist > weapon.s.headshotDistance )
			return false

		return weapon.GetAllowHeadShots()
	}
	else if ( IsValid( inflictor ) && inflictor.IsProjectile() )
	{
		if ( !( "headshotDistance" in inflictor.s ) )
			inflictor.s.headshotDistance <- inflictor.GetProjectileWeaponSettingFloat( eWeaponVar.damage_far_distance )

		if ( inflictor.s.headshotDistance != null && attackDist > inflictor.s.headshotDistance )
			return false

		return expect bool( inflictor.GetProjectileAllowHeadShots() )
	}

	return false
}

bool function IsMaxRangeShot( damageInfo )
{
	entity weapon = DamageInfo_GetWeapon( damageInfo )
	entity inflictor = DamageInfo_GetInflictor( damageInfo )

	local nearDamage
	local farDamage
	if ( IsValid( weapon ) )
	{
		nearDamage = weapon.GetWeaponSettingInt( eWeaponVar.damage_near_value )
		farDamage = weapon.GetWeaponSettingInt( eWeaponVar.damage_far_value )

		if ( !( "headshotDistance" in weapon.s ) )
			weapon.s.headshotDistance <- weapon.GetMaxDamageFarDist()
	}
	else
	{
		weapon = inflictor
		if ( !IsValid( weapon ) || !weapon.IsProjectile() )
			return false

		nearDamage = weapon.GetProjectileWeaponSettingInt( eWeaponVar.damage_near_value )
		farDamage = weapon.GetProjectileWeaponSettingInt( eWeaponVar.damage_far_value )

		if ( !( "headshotDistance" in weapon.s ) )
			weapon.s.headshotDistance <- weapon.GetProjectileWeaponSettingFloat( eWeaponVar.damage_far_distance )
	}

	if ( farDamage >= nearDamage ) // if the far damage is better than near damage, then "max range" is never really valid
		return false

	Assert( weapon.s.headshotDistance != null )
	if ( DamageInfo_GetDistFromAttackOrigin( damageInfo ) > weapon.s.headshotDistance )
		return true

	return false
}

bool function IsMidRangeShot( damageInfo )
{
	entity weapon = DamageInfo_GetWeapon( damageInfo )
	entity inflictor = DamageInfo_GetInflictor( damageInfo )

	float nearDist
	float farDist
	if ( IsValid( weapon ) )
	{
		nearDist = weapon.GetWeaponSettingFloat( eWeaponVar.damage_near_distance )
		farDist = weapon.GetWeaponSettingFloat( eWeaponVar.damage_far_distance )
	}
	else
	{
		weapon = inflictor
		if ( !IsValid( weapon ) || !weapon.IsProjectile() )
			return false

		nearDist = weapon.GetProjectileWeaponSettingFloat( eWeaponVar.damage_near_distance )
		farDist = weapon.GetProjectileWeaponSettingFloat( eWeaponVar.damage_far_distance )
	}

	if ( farDist <= nearDist ) // if the far damage is better than near damage, then "max range" is never really valid
		return false

	//if ( DamageInfo_GetDistFromAttackOrigin( damageInfo ) > nearDist + ((farDist - nearDist) * 0.5))
	if ( DamageInfo_GetDistFromAttackOrigin( damageInfo ) > nearDist )
		return true

	return false
}

bool function IsInstantDeath( var damageInfo )
{
	int damageSourceID = DamageInfo_GetDamageSourceIdentifier( damageInfo )

	switch ( damageSourceID )
	{
		case eDamageSourceId.titan_execution:
		case eDamageSourceId.human_execution:
		case eDamageSourceId.fall:
		case eDamageSourceId.splat:
		case eDamageSourceId.lasergrid:
		case eDamageSourceId.indoor_inferno:
		case damagedef_suicide:
			return true

		default:
			return false
	}

	unreachable
}

bool function IsTitanCrushDamage( damageInfo )
{
	if ( DamageInfo_GetCustomDamageType( damageInfo ) == damageTypes.titanStepCrush )
		return true

	// code detected footstep damage gives this damage source ID
	if ( DamageInfo_GetDamageSourceIdentifier( damageInfo ) == damagedef_titan_step )
		return true

	return false
}

bool function IsSuicide( entity attacker, entity victim, int damageSourceId )
{
	if ( attacker == victim )
		return true

	if ( damageSourceId == damagedef_suicide )
		return true

	if ( damageSourceId == eDamageSourceId.outOfBounds )
		return true

	return false
}

#if CLIENT

void function ServerCallback_QuickDeathRumble()
{
	entity player = GetLocalClientPlayer()
	if ( IsValid( player ) )
		Rumble_Play( "QuickDeath", { position = player.GetOrigin() } )
}

#endif // CLIENT