untyped
global function SPDifficulty_Init

global function UpdateNPCForSpDifficulty

global function SPMP_Callback_ForceAIMissPlayer
global function UpdateSpDifficulty
global function GetSpDifficulty
global function GetDamageScalarByDifficulty
global function SetProficiencyFromSPDifficulty
global function SelectDifficulty
global function GetLowestDifficultyThisMap
global function UpdateMercTitanHealthForDifficulty

const float FRIENDLY_TVT_DAMAGE_SCALE = 0.2 // scale damage dealt by militia npc titans against IMC
const float BT_TVT_DAMAGE_SCALE = 0.5 // scale damage dealt by BT npc against IMC titans
const float PLAYER_TITAN_PVT_OUT_OF_VIEW_DAMAGE_FORGIVENESS = 0.4 // damage is multiplied by this amount for out of view enemies dealing damage to player (as titan)
const float MFP_CHANCE_TO_HIT = 0.5 // Extra chance to miss if player is fast.

// ok chat you might be wondering "hmmm why the fuck did you give damage resist on all difficulties"
// WELL, i dont want people to be punished for being aggressive. high damage multipliers mean
// that the player dies before they can actually retaliate, forcing them to basically fuckin hide
// and cower. i want them to get CLOSE AND PERSONAL, not fuckin hide.
const float DIFFICULTY_EASY_DAMAGE_SCALAR = 0.75 // damage against player is multiplied by this number on Easy.
const float DIFFICULTY_NORMAL_DAMAGE_SCALAR = 1.0 // damage against player is multiplied by this number on Normal.
const float DIFFICULTY_HARD_DAMAGE_SCALAR = 1.0 // damage against player is multiplied by this number on Hard.
// NO INCREASE HERE, TITANS HAVE 0 CD HERE LOL
const float DIFFICULTY_MASTER_DAMAGE_SCALAR = 1.0 // damage against player is multiplied by this number on Master.
const float PLAYER_TITAN_DAMAGE_SCALAR = 1 // damage against player titan multiplied by this

struct
{
	int lowestDifficulty = 999
	float maxDamagePerHit
} file

void function UpdateSpDifficulty( entity player )
{
	int difficulty = GetSpDifficulty()
	
	// somewhere between hard and master i think
	NPCSetAimConeFocusParams( 1.0, 3.0 )
	NPCSetAimPatternFocusParams( 2, 0.5, 0.8 )
	NPCSetReacquireParams( 2.5, 2 ) // forget quickly about targets
	file.maxDamagePerHit = 50

	if ( IsAlive( player ) && IsPilot( player ) )
		ScaleHealthForDifficulty( player, difficulty )

	array<entity> npcs = GetNPCArray()
	foreach ( npc in npcs )
	{
		UpdateNPCForSpDifficulty( npc )
	}

	if ( DevStartPoints() )
	{
		foreach ( player in GetPlayerArray() )
		{
			Remote_CallFunction_NonReplay( player, "ServerCallback_UpdateDifficulty" )
		}
	}
}


void function SPDifficulty_Init()
{
	Assert( !IsMultiplayer() )

	AddDamageCallback( "npc_titan", NPCTitan_OnDamaged )
	AddDamageCallback( "player", SpPlayer_OnDamaged )

	// titans are easier when player is doomed
	AddSpawnCallback( "npc_titan", NPCTitan_OnSpawned )
	AddCallback_OnTitanDoomed( OnTitanDoomed )
	AddClientCommandCallback( "ClientCommand_RequestSPDifficultyChange", ClientCommand_RequestSPDifficultyChange )

	file.lowestDifficulty = GetSpDifficulty()
}

void function NPCTitan_OnSpawned( entity titan )
{
	titan.SetNPCFlag( NPC_NO_WEAPON_DROP, true )

	foreach ( p in GetPlayerArray() )
	{
		entity playerTitan = GetTitanFromPlayer( p )
		if ( IsAlive( playerTitan ) && GetDoomedState( playerTitan ) )
		{
			titan.kv.WeaponProficiency = titan.ai.playerDoomedProficiency
		}
	}
}

void function OnTitanDoomed( entity titan, var damageInfo )
{
	if ( titan.IsPlayer() || titan.GetBossPlayer() != null )
	{
		LowerNPCTitanProficiency()
	}
}

void function NPCTitan_OnDamaged( entity titan, var damageInfo )
{
	if ( DamageInfo_GetForceKill( damageInfo ) )
		return

	if ( titan.GetTeam() == TEAM_IMC )
	{
		entity attacker = DamageInfo_GetAttacker( damageInfo )
		if ( attacker.IsNPC() && attacker.IsTitan() )
		{
			if ( IsAlive( attacker.GetBossPlayer() ) )
				DamageInfo_ScaleDamage( damageInfo, BT_TVT_DAMAGE_SCALE )
			else
				DamageInfo_ScaleDamage( damageInfo, FRIENDLY_TVT_DAMAGE_SCALE ) // friendly titan only does 20% damage
		}
	}
	else
	{
		if ( IsAlive( titan.GetBossPlayer() ) )
		{
			// its BT! Scale incoming damage so BT doesn't die right away
			float healthRatio = float( titan.GetHealth() ) / titan.GetMaxHealth()
			float scale = GraphCapped( healthRatio, 0.4, 0.7, 0.20, 1.00 )
			DamageInfo_ScaleDamage( damageInfo, scale )
		}
	}
}

void function SpPlayer_OnDamaged( entity player, var damageInfo )
{
	// reduce incoming damage if you recently loaded a save
	DamageInfo_ScaleDamage( damageInfo, LoadSaveTimeDamageMultiplier() )


	entity attacker = DamageInfo_GetAttacker( damageInfo )
	if ( attacker == player )
		return

	if ( player.IsTitan() )
	{
		int armor = Roguelike_GetStat( player, STAT_ARMOR )
		DamageInfo_ScaleDamage( damageInfo, Roguelike_GetTitanDamageMultiplier( armor ) )
		
		ScaleDamageToPlayerByDifficulty( damageInfo )

		DamageInfo_ScaleDamage( damageInfo, PLAYER_TITAN_DAMAGE_SCALAR )

		if ( IsHumanSized( attacker ) )
		{
			DamageInfo_ScaleDamage( damageInfo, PLAYER_TITAN_PVT_OUT_OF_VIEW_DAMAGE_FORGIVENESS )
		}
	}
	else
	{
		ScaleDamageToPlayerByDifficulty( damageInfo )

		if ( !DamageAlwaysLethal( damageInfo ) )
		{
			float recentDamage = GetTotalDamageTakenInTime( player, 0.25 )
			float maxDamageAllowed = max( 5, file.maxDamagePerHit - recentDamage )


			// make it possible to beat a Titan
			if ( DamageInfo_GetDamage( damageInfo ) > maxDamageAllowed )
			{
				DamageInfo_SetDamage( damageInfo, maxDamageAllowed )
			}
		}
	}
}

void function LowerNPCTitanProficiency()
{
	array<entity> npcs = GetNPCArrayOfTeam( TEAM_IMC )
	foreach ( ai in npcs )
	{
		if ( IsAlive( ai ) )
		{
			if ( !ai.IsTitan() )
				continue

			printt( ai + ": lowering proficiency to: " + ai.ai.playerDoomedProficiency )
			ai.kv.WeaponProficiency = ai.ai.playerDoomedProficiency
		}
	}
}

void function RestoreNPCTitanProficiency()
{
	array<entity> npcs = GetNPCArrayOfTeam( TEAM_IMC )
	foreach ( ai in npcs )
	{
		if ( IsAlive( ai ) )
		{
			if ( !ai.IsTitan() )
				continue

			ai.kv.WeaponProficiency = ai.ai.defaultProficiency
		}
	}
}

void function ScaleDamageToPlayerByDifficulty( var damageInfo )
{
	int difficulty = GetSpDifficulty()
	float scalar

	switch ( difficulty )
	{
		case DIFFICULTY_EASY:
			scalar = DIFFICULTY_EASY_DAMAGE_SCALAR
			break

		case DIFFICULTY_NORMAL:
			scalar = DIFFICULTY_NORMAL_DAMAGE_SCALAR
			break

		case DIFFICULTY_HARD:
			scalar = DIFFICULTY_HARD_DAMAGE_SCALAR
			break

		case DIFFICULTY_MASTER:
			scalar = DIFFICULTY_MASTER_DAMAGE_SCALAR
			break

		default:
			return
	}

	DamageInfo_ScaleDamage( damageInfo, scalar )
}

float function GetDamageScalarByDifficulty()
{
	int difficulty = GetSpDifficulty()
	float scalar = DIFFICULTY_NORMAL_DAMAGE_SCALAR

	switch ( difficulty )
	{
		case DIFFICULTY_EASY:
			scalar = DIFFICULTY_EASY_DAMAGE_SCALAR
			break

		case DIFFICULTY_NORMAL:
			scalar = DIFFICULTY_NORMAL_DAMAGE_SCALAR
			break

		case DIFFICULTY_HARD:
			scalar = DIFFICULTY_HARD_DAMAGE_SCALAR
			break

		case DIFFICULTY_MASTER:
			scalar = DIFFICULTY_MASTER_DAMAGE_SCALAR
			break
	}

	return scalar
}

int function GetSpDifficulty()
{
	int difficulty = GetConVarInt( "sp_difficulty" )
	return int( clamp( difficulty, DIFFICULTY_EASY, DIFFICULTY_MASTER ) )
}

void function ScaleHealthForDifficulty( entity player, int difficulty )
{
	float scale = 1.0
	switch ( difficulty )
	{
		case 0:
			//scale = 1.5
			break
		case 1:
			//scale = 1.25
			break
		case 2:
		case 3:
			break
	}
	ScaleHealth( player, scale )
}

void function SetTitanProficiency( entity npcTitan )
{
	if ( npcTitan.GetAIClass() == AIC_TITAN_BUDDY )
	{
		npcTitan.kv.WeaponProficiency = eWeaponProficiency.PERFECT
	}
	else
	{
		// should be difficulty based numbers
		int difficulty = GetSpDifficulty()
		npcTitan.kv.accuracyMultiplier = 2

		if ( !IsBossTitan( npcTitan ) )
			npcTitan.kv.WeaponProficiency = eWeaponProficiency.PERFECT
		else
			npcTitan.kv.WeaponProficiency = eWeaponProficiency.PERFECT // tuned to not be exact perfect

		if ( npcTitan.HasKey( "ProficiencyAdjust" ) )
		{
			int proficiencyAdjust = int( npcTitan.kv.ProficiencyAdjust )
			int weaponProficiency = int( npcTitan.kv.WeaponProficiency )
			int newProf = int( clamp( weaponProficiency + proficiencyAdjust, eWeaponProficiency.POOR, eWeaponProficiency.PERFECT ) )

			// printt( npcTitan )
			// printt( npcTitan.kv.WeaponProficiency )
			// printt( newProf )

			npcTitan.kv.WeaponProficiency = newProf
		}
	}

	int weaponProficiency = int( npcTitan.kv.WeaponProficiency )

	npcTitan.ai.playerDoomedProficiency = int( clamp( weaponProficiency - 1, eWeaponProficiency.POOR, eWeaponProficiency.PERFECT ) )
	npcTitan.ai.defaultProficiency = weaponProficiency
}

void function UpdateNPCForSpDifficulty( entity npc )
{
	if ( npc.IsTitan() )
	{
		SetTitanProficiency( npc )
		UpdateMercTitanHealthForDifficulty( npc )

		return
	}

	SetProficiencyFromSPDifficulty( npc )
}

void function UpdateMercTitanHealthForDifficulty( entity npc )
{
	// do not scale ally health
	if (npc.GetTeam() != TEAM_IMC)
		return
	float multiplier = (IsMercTitan( npc ) && !GetDoomedState( npc )) ? 2.0 : 1.0
	switch (GetSpDifficulty())
	{
		case DIFFICULTY_EASY:
			RescaleHealthWithMultiplier( npc, 0.8 * multiplier )
			break
		case DIFFICULTY_NORMAL:
			RescaleHealthWithMultiplier( npc, 1.0 * multiplier )
			break
		case DIFFICULTY_HARD:
			RescaleHealthWithMultiplier( npc, 1.33334 * multiplier )
			break
		case DIFFICULTY_MASTER:
			RescaleHealthWithMultiplier( npc, 1.66667 * multiplier )
			break
	}
}

bool function SPMP_Callback_ForceAIMissPlayer( entity npc, entity player )
{
	entity weapon = npc.GetActiveWeapon()
	if ( !IsValid( weapon ) )
		return false

/*
	float recentDamage = TotalDamageOverTime_BlendedOut( player, 1.5, 3.0 )

	float damageMissChance = GraphCapped( recentDamage, 20, 100, 0.0, 1.0 )
	if ( RandomFloat( 1.0 ) < damageMissChance )
		return true
*/

	float chanceToHit = 1.0

	if ( player.IsTitan() )
		return false

	vector velocity = player.GetVelocity()
	float speed = Length( velocity )

	if (!player.IsOnGround())
	{
		chanceToHit *= 0.75
	}

	vector entDif = npc.GetOrigin() - player.GetOrigin()
	float dist = Length( entDif )
	entDif = Normalize( entDif )
	velocity = Normalize( velocity )
	float dot = DotProduct( entDif, velocity )
	
	if ( speed > 350 )
		chanceToHit *= GraphCapped( speed, 350, 800, 0.75, 0.0 )

	if ( dot < 0.8 && speed > 0 )
		chanceToHit *= 0.75

	printt("chanceToHit", chanceToHit)
	float rand = RandomFloat( 1.0 )
	printt(rand, ">", chanceToHit, rand > chanceToHit)
	return rand > chanceToHit
}

void function SetProficiencyFromSPDifficulty( entity soldier )
{
	entity enemy = soldier.GetEnemy()
	int weaponProficiency = eWeaponProficiency.AVERAGE

	if ( IsAlive( enemy ) && enemy.IsPlayer() && !IsValidRocketTarget( enemy ) )
	{
		weaponProficiency = eWeaponProficiency.AVERAGE
	}

	if (!soldier.IsTitan())
	switch (GetSpDifficulty())
	{
		case DIFFICULTY_EASY:
			RescaleHealthWithMultiplier( soldier, 1.0 )
			break
		case DIFFICULTY_NORMAL:
			RescaleHealthWithMultiplier( soldier, 1.0 )
			break
		case DIFFICULTY_HARD:
			RescaleHealthWithMultiplier( soldier, 1.1 )
			break
		case DIFFICULTY_MASTER:
			RescaleHealthWithMultiplier( soldier, 1.2 )
			break
	}

	soldier.kv.WeaponProficiency = weaponProficiency
}

void function RescaleHealthWithMultiplier( entity npc, float multiplier )
{
	if (!IsAlive( npc ))
		return
	float healthFrac = GetHealthFrac( npc )
	float health = 100.0
	if (!("baseHealth" in npc.s) && npc.IsTitan())
		return
	
	if (npc.IsTitan())
	{
		printt("base health", float(npc.s.baseHealth))
		health = float(npc.s.baseHealth)
	}
	else
	{
		health = float( npc.Dev_GetAISettingByKeyField( "Health" ) )
	}

	npc.SetMaxHealth( health * multiplier )
	npc.SetHealth( npc.GetMaxHealth() * healthFrac )
}

void function SelectDifficulty( int difficulty )
{
	array<entity> players = GetPlayerArray()
	if ( !players.len() )
		return

	printt( "Set difficulty to " + difficulty )
	SetConVarInt( "sp_difficulty", difficulty )

	file.lowestDifficulty = minint( file.lowestDifficulty, difficulty )

	foreach ( player in players )
	{
		UpdateSpDifficulty( player )
	}
}


bool function ClientCommand_RequestSPDifficultyChange( entity player, array<string> args )
{
	int difficulty
	if ( args.len() != 1 )
		return false
	difficulty = int( args[0] )
	SelectDifficulty( difficulty )
	return true
}


int function GetLowestDifficultyThisMap()
{
	return file.lowestDifficulty
}